import matplotlib.pyplot as plt
from scipy.integrate import odeint, solve_bvp, solve_ivp
import numpy as np

'''
    Чтобы быть совместимым с формой параметров resolve_ivp, порядок параметров, определенный функцией дифференциального уравнения, равен (t, y), поэтому при использовании функции odeint параметр tfirst = True
         Дифференциальные уравнения второго или даже более высокого порядка могут быть заменены переменными в виде уравнений первого порядка, а затем для их решения вызываются связанные функции. Поэтому при записи функций, в отличие от дифференциальных уравнений первого порядка, используются уравнения второго порядка. или дифференциальные уравнения высокого порядка возвращают низкий уровень Система уравнений от порядка к более высокому порядку,
'''

k = 2
E = 1
alpha = 1


def fvdp1(t, y):
    '''
         Чтобы увидеть y как вектор, y = [dy0, dy1, dy2, ...] представляет собой n-ю производную y, тогда
         y [0] - это решаемая функция, y [1] представляет первую производную, y [2] представляет вторую производную и т. д.
    '''
    dy1 = y[1]  # y [1] = dy / dt, производная первого порядка

    dy2 = - 2 * k * (y[0]) ** (k - 1)
    # y [0] - самая начальная функция, которую нужно решить.
    # Обратите внимание, что порядок возврата - [производная первого порядка, производная второго порядка], который образует систему дифференциальных уравнений первого порядка
    return [dy1, dy2]


# Или проще написать следующее
def fvdp2(t, y):
    '''
         Чтобы рассматривать y как вектор, y = [dy0, dy1, dy2, ...] соответственно представляют производную n-го порядка от y.
         Для дифференциальных уравнений второго порядка это должна быть комбинация функций 0-го и 1-го порядка, поэтому, если y рассматривается как вектор ниже, y0 представляет начальную функцию, которая является функцией, которую нам нужно решить, а y1 представляет первая производная.То же самое можно сказать и о дифференциальных уравнениях высшего порядка.
    '''
    y0, y1 = y
    # y0 - это решаемая функция, y1 - первая производная
    # Порядок возврата - [производная первого порядка, производная второго порядка], который образует систему дифференциальных уравнений первого порядка
    dydt = [y1, -3 * y1 - 2 * y0 + np.exp(-t)]

    return dydt


def solve_second_order_ode():
    '''
         Решить ОДУ второго порядка
    '''
    t2 = np.linspace(0, 20, 1000)
    tspan = (0, 20.0)

    y0 = [E / alpha * (1 / k), 0]  # Условия начального значения
    # Начальное значение [2,0] означает y (0) = 2, y '(0) = 0
    # Возвращаем y, где y [:, 0] - это значение y [0], которое является окончательным решением, а y [:, 1] - это значение y '(x)
    y = odeint(fvdp1, y0, t2, tfirst=True)

    y_ = solve_ivp(fvdp2, t_span=tspan, y0=y0, t_eval=t2)

    plt.subplot(211)
    y1, = plt.plot(t2, y[:, 0], label='y')
    # y1_1, = plt.plot(t2, y[:, 1], label='y‘')
    # plt.legend(handles=[y1, y1_1])
    plt.legend(handles=[y1])

    plt.subplot(212)
    y2, = plt.plot(y_.t, y_.y[0, :], 'g--', label='y(0)')
    y2_2, = plt.plot(y_.t, y_.y[1, :], 'r-', label='y(1)')
    plt.legend(handles=[y2, y2_2])

    plt.show()


solve_second_order_ode()
